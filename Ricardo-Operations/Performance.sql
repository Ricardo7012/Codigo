USE HSP_Prime
GO
--SEE HOW THE TOTAL NUMBER OF ALLOCATED BUFFERS (NUM PROC BUFFS) 
--COMPARES WITH THE NUMBER USED (NUM PROC BUFFS USED). 
--A HIGH-VALUE PERCENTAGE INDICATES POOR USE OF PROCEDURE CACHE.
DBCC PROCCACHE 

--OBSERVE THE VALUES FOR BUFFER DISTRIBUTION TABLE. IF THE NUMBER OF TARGETED PAGES DECREASES OVER TIME, 
--IT IS LIKELY THAT YOUR SQL SERVER IS EXPERIENCING EXTERNAL MEMORY PRESSURE. 
--COMPARE THE NUMBER OF TARGETED PAGES AGAINST THE STOLEN PAGES. 
--IF THE NUMBER OF STOLEN PAGES DOES NOT STABILIZE OVER TIME, THE SERVER MAY EVENTUALLY GET INTO INTERNAL PHYSICAL MEMORY PRESSURE. 
DBCC MEMORYSTATUS

--
SELECT * FROM SYS.SYSPERFINFO WHERE
OBJECT_NAME='SQLSERVER:BUFFER MANAGER' AND
(COUNTER_NAME='TARGET PAGES' OR
COUNTER_NAME='TOTAL PAGES' OR
COUNTER_NAME='DATABASE PAGES' OR
COUNTER_NAME='STOLEN PAGES' OR
COUNTER_NAME='FREE PAGES')

--DETERMINE WHICH SQL SERVER COMPONENTS ARE CONSUMING THE MOST AMOUNT OF MEMORY, AND OBSERVE HOW THIS CHANGES OVER TIME:
SELECT TYPE, SUM(PAGES_KB) as PagesKB
FROM SYS.DM_OS_MEMORY_CLERKS 
WHERE PAGES_KB != 0 GROUP BY TYPE ORDER BY PagesKB desc

--This query will show which SQL Server objects are consuming memory:

SELECT TYPE, exclusive_access_count 
FROM
SYS.DM_OS_MEMORY_OBJECTS WHERE
PAGE_ALLOCATOR_ADDRESS IN (SELECT TOP 10
PAGE_ALLOCATOR_ADDRESS FROM
SYS.DM_OS_MEMORY_CLERKS ORDER BY
PAGES_KB DESC) ORDER BY
exclusive_access_count DESC

--select * from SYS.dm_os_memory_objects

--To get an idea of which individual processes are taking up memory, use the following query:

SELECT TOP 10 SESSION_ID, LOGIN_TIME, HOST_NAME,
PROGRAM_NAME, LOGIN_NAME, NT_DOMAIN, 
NT_USER_NAME, STATUS, CPU_TIME, MEMORY_USAGE, 
TOTAL_SCHEDULED_TIME, TOTAL_ELAPSED_TIME, 
LAST_REQUEST_START_TIME,
LAST_REQUEST_END_TIME, READS, WRITES, 
LOGICAL_READS, TRANSACTION_ISOLATION_LEVEL, 
LOCK_TIMEOUT, DEADLOCK_PRIORITY, ROW_COUNT, 
PREV_ERROR FROM SYS.DM_EXEC_SESSIONS ORDER
BY MEMORY_USAGE DESC

--TO SOLVE MEMORY PROBLEMS, SEE IF SQL SERVER MEMORY IS CORRECTLY ALLOCATED. IF SO, ENSURE THAT THE PROCEDURE CACHE HAS NOT BEEN SQUEEZED. TYPICAL CULPRITS EATING UP PROCEDURE CACHE ARE LARGE STORED PROCEDURES OR LARGE AMOUNTS OF AD HOC SQL THAT ARE NOT PARAMETERIZED. THEN EXAMINE LARGE MEMORY CONSUMERS AND OBJECTS TO SEE IF YOUR APPLICATIONS NEED RE-ARCHITECTING. PROCESSES CONSUMING LARGE AMOUNTS OF MEMORY SHOULD BE REDESIGNED TO CONSUME LESS MEMORY

--Processes that are disk intensive typically do not have the appropriate indexes or have poor execution plans. Here is a DMV query that lists the top 25 tables experiencing I/O waits.
SELECT TOP 25 DB_NAME(D.DATABASE_ID) AS
DATABASE_NAME, 
QUOTENAME(OBJECT_SCHEMA_NAME(D.OBJECT_ID, 
D.DATABASE_ID)) + N'.' +
QUOTENAME(OBJECT_NAME(D.OBJECT_ID,
D.DATABASE_ID)) AS OBJECT_NAME, D.DATABASE_ID, 
D.OBJECT_ID, D.PAGE_IO_LATCH_WAIT_COUNT,
D.PAGE_IO_LATCH_WAIT_IN_MS, D.RANGE_SCANS,
D.INDEX_LOOKUPS FROM (SELECT DATABASE_ID, 
OBJECT_ID, ROW_NUMBER() OVER (PARTITION BY
DATABASE_ID ORDER BY
SUM(PAGE_IO_LATCH_WAIT_IN_MS) DESC) AS
ROW_NUMBER, SUM(PAGE_IO_LATCH_WAIT_COUNT) AS
PAGE_IO_LATCH_WAIT_COUNT, 
SUM(PAGE_IO_LATCH_WAIT_IN_MS) AS
PAGE_IO_LATCH_WAIT_IN_MS, 
SUM(RANGE_SCAN_COUNT) AS RANGE_SCANS, 
SUM(SINGLETON_LOOKUP_COUNT) AS
INDEX_LOOKUPS FROM
SYS.DM_DB_INDEX_OPERATIONAL_STATS(NULL, NULL, 
NULL, NULL) WHERE PAGE_IO_LATCH_WAIT_COUNT > 0
GROUP BY DATABASE_ID, OBJECT_ID ) AS D LEFT JOIN
(SELECT DISTINCT DATABASE_ID, OBJECT_ID FROM
SYS.DM_DB_MISSING_INDEX_DETAILS) AS MID ON
MID.DATABASE_ID = D.DATABASE_ID AND
MID.OBJECT_ID = D.OBJECT_ID WHERE
D.ROW_NUMBER>20 ORDER BY
PAGE_IO_LATCH_WAIT_COUNT DESC

--YOU CAN ALSO GENERATE A LIST OF COLUMNS THAT SHOULD HAVE INDEXES ON THEM:

SELECT * FROM SYS.DM_DB_MISSING_INDEX_GROUPS
G JOIN SYS.DM_DB_MISSING_INDEX_GROUP_STATS GS
ON GS.GROUP_HANDLE = G.INDEX_GROUP_HANDLE
JOIN SYS.DM_DB_MISSING_INDEX_DETAILS D ON
G.INDEX_HANDLE = D.INDEX_HANDLE


--CPU. One of the most frequent contributors to high CPU consumption is stored procedure recompilation. Here is a DMV that displays the list of the top 25 recompilations:
SELECT TOP 25 SQL_TEXT.TEXT, SQL_HANDLE, 
PLAN_GENERATION_NUM, EXECUTION_COUNT, DBID, 
OBJECTID FROM SYS.DM_EXEC_QUERY_STATS A
CROSS APPLY SYS.DM_EXEC_SQL_TEXT(SQL_HANDLE) 
AS SQL_TEXT WHERE PLAN_GENERATION_NUM >1
ORDER BY PLAN_GENERATION_NUM DESC


--LISTS THE TOP CPU CONSUMERS:

SELECT TOP 50 SUM(QS.TOTAL_WORKER_TIME) AS
TOTAL_CPU_TIME, SUM(QS.EXECUTION_COUNT) AS
TOTAL_EXECUTION_COUNT, COUNT(*) AS
NUMBER_OF_STATEMENTS, SQL_TEXT.TEXT, 
QS.PLAN_HANDLE FROM SYS.DM_EXEC_QUERY_STATS
QS CROSS APPLY
SYS.DM_EXEC_SQL_TEXT(SQL_HANDLE) AS SQL_TEXT
GROUP BY SQL_TEXT.TEXT,QS.PLAN_HANDLE ORDER
BY SUM(QS.TOTAL_WORKER_TIME) DESC

--OTHER THINGS THAT CAUSE HIGH CPU USAGE ARE BOOKMARK LOOKUPS, BAD PARALLELISM AND LOOPING CODE.

--NOTE

--WHEN SEARCHING FOR BOTTLENECKS, LOOK FOR MEMORY BOTTLENECKS, THEN DISK AND FINALLY CPU. 
--CAPTURE A BASELINE USING SYSTEM MONITOR, SQL PROFILER AND DMVS TO DETERMINE WHAT IS CAUSING THE 
--BOTTLENECK AND IF IT CAN BE SOLVED BY A HARDWARE UPGRADE. ONCE YOU HAVE A BASELINE, YOU ARE READY 
--TO START DIAGNOSING THE PROBLEM. IN MOST CASES, THE SOLUTION WILL INVOLVE QUERY TUNING, QUERY 
--REWRITES OR RE-ARCHITECTING YOUR SOLUTION. MANY TIMES, THROWING HARDWARE AT THE PROBLEM WILL 
--NOT HAVE THE PERFORMANCE GAINS OF SIMPLE INDEX PLACEMENT

--Just note that the counter type for all three counters is 272696576 and that the values shown are cumulative since the last SQL Server start, so they have to be calculated. One of the methods is to take two samples with a 10-second delay
select * from sys.dm_os_performance_counters 
where counter_name in ('Batch Requests/sec', 'SQL Compilations/sec' , 'SQL Re-Compilations/sec') 

--The Batch Requests/sec value depends on hardware used, but it should be under 1000. The recommended value for SQL Compilations/sec is less than 10% of Batch Requests/sec and for SQL Re-Compilations/sec is less than 10% of SQL Compilations/sec
DECLARE @BatchRequests BIGINT;
 
SELECT @BatchRequests = cntr_value
FROM sys.dm_os_performance_counters
WHERE counter_name = 'Batch Requests/sec';
 
WAITFOR DELAY '00:00:10';
 
SELECT (cntr_value - @BatchRequests) / 10 AS 'Batch Requests/sec'
FROM sys.dm_os_performance_counters
WHERE counter_name = 'Batch Requests/sec';




